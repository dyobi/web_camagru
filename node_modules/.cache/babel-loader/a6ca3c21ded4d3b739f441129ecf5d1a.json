{"ast":null,"code":"'use strict';\n\nconst shared = require('../shared');\n\nconst MimeNode = require('../mime-node');\n\nconst mimeFuncs = require('../mime-funcs');\n\nclass MailMessage {\n  constructor(mailer, data) {\n    this.mailer = mailer;\n    this.data = {};\n    this.message = null;\n    data = data || {};\n    let options = mailer.options || {};\n    let defaults = mailer._defaults || {};\n    Object.keys(data).forEach(key => {\n      this.data[key] = data[key];\n    });\n    this.data.headers = this.data.headers || {}; // apply defaults\n\n    Object.keys(defaults).forEach(key => {\n      if (!(key in this.data)) {\n        this.data[key] = defaults[key];\n      } else if (key === 'headers') {\n        // headers is a special case. Allow setting individual default headers\n        Object.keys(defaults.headers).forEach(key => {\n          if (!(key in this.data.headers)) {\n            this.data.headers[key] = defaults.headers[key];\n          }\n        });\n      }\n    }); // force specific keys from transporter options\n\n    ['disableFileAccess', 'disableUrlAccess', 'normalizeHeaderKey'].forEach(key => {\n      if (key in options) {\n        this.data[key] = options[key];\n      }\n    });\n  }\n\n  resolveContent(...args) {\n    return shared.resolveContent(...args);\n  }\n\n  resolveAll(callback) {\n    let keys = [[this.data, 'html'], [this.data, 'text'], [this.data, 'watchHtml'], [this.data, 'amp'], [this.data, 'icalEvent']];\n\n    if (this.data.alternatives && this.data.alternatives.length) {\n      this.data.alternatives.forEach((alternative, i) => {\n        keys.push([this.data.alternatives, i]);\n      });\n    }\n\n    if (this.data.attachments && this.data.attachments.length) {\n      this.data.attachments.forEach((attachment, i) => {\n        if (!attachment.filename) {\n          attachment.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n\n          if (attachment.filename.indexOf('.') < 0) {\n            attachment.filename += '.' + mimeFuncs.detectExtension(attachment.contentType);\n          }\n        }\n\n        if (!attachment.contentType) {\n          attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');\n        }\n\n        keys.push([this.data.attachments, i]);\n      });\n    }\n\n    let mimeNode = new MimeNode();\n    let addressKeys = ['from', 'to', 'cc', 'bcc', 'sender', 'replyTo'];\n    addressKeys.forEach(address => {\n      let value;\n\n      if (this.message) {\n        value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === 'replyTo' ? 'reply-to' : address)) || []);\n      } else if (this.data[address]) {\n        value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);\n      }\n\n      if (value && value.length) {\n        this.data[address] = value;\n      } else if (address in this.data) {\n        this.data[address] = null;\n      }\n    });\n    let singleKeys = ['from', 'sender', 'replyTo'];\n    singleKeys.forEach(address => {\n      if (this.data[address]) {\n        this.data[address] = this.data[address].shift();\n      }\n    });\n    let pos = 0;\n\n    let resolveNext = () => {\n      if (pos >= keys.length) {\n        return callback(null, this.data);\n      }\n\n      let args = keys[pos++];\n\n      if (!args[0] || !args[0][args[1]]) {\n        return resolveNext();\n      }\n\n      shared.resolveContent(...args, (err, value) => {\n        if (err) {\n          return callback(err);\n        }\n\n        let node = {\n          content: value\n        };\n\n        if (args[0][args[1]] && typeof args[0][args[1]] === 'object' && !Buffer.isBuffer(args[0][args[1]])) {\n          Object.keys(args[0][args[1]]).forEach(key => {\n            if (!(key in node) && !['content', 'path', 'href', 'raw'].includes(key)) {\n              node[key] = args[0][args[1]][key];\n            }\n          });\n        }\n\n        args[0][args[1]] = node;\n        resolveNext();\n      });\n    };\n\n    setImmediate(() => resolveNext());\n  }\n\n  normalize(callback) {\n    let envelope = this.data.envelope || this.message.getEnvelope();\n    let messageId = this.message.messageId();\n    this.resolveAll((err, data) => {\n      if (err) {\n        return callback(err);\n      }\n\n      data.envelope = envelope;\n      data.messageId = messageId;\n      ['html', 'text', 'watchHtml', 'amp'].forEach(key => {\n        if (data[key] && data[key].content) {\n          if (typeof data[key].content === 'string') {\n            data[key] = data[key].content;\n          } else if (Buffer.isBuffer(data[key].content)) {\n            data[key] = data[key].content.toString();\n          }\n        }\n      });\n\n      if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {\n        data.icalEvent.content = data.icalEvent.content.toString('base64');\n        data.icalEvent.encoding = 'base64';\n      }\n\n      if (data.alternatives && data.alternatives.length) {\n        data.alternatives.forEach(alternative => {\n          if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {\n            alternative.content = alternative.content.toString('base64');\n            alternative.encoding = 'base64';\n          }\n        });\n      }\n\n      if (data.attachments && data.attachments.length) {\n        data.attachments.forEach(attachment => {\n          if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {\n            attachment.content = attachment.content.toString('base64');\n            attachment.encoding = 'base64';\n          }\n        });\n      }\n\n      data.normalizedHeaders = {};\n      Object.keys(data.headers || {}).forEach(key => {\n        let value = [].concat(data.headers[key] || []).shift();\n        value = value && value.value || value;\n\n        if (value) {\n          if (['references', 'in-reply-to', 'message-id', 'content-id'].includes(key)) {\n            value = this.message._encodeHeaderValue(key, value);\n          }\n\n          data.normalizedHeaders[key] = value;\n        }\n      });\n\n      if (data.list && typeof data.list === 'object') {\n        let listHeaders = this._getListHeaders(data.list);\n\n        listHeaders.forEach(entry => {\n          data.normalizedHeaders[entry.key] = entry.value.map(val => val && val.value || val).join(', ');\n        });\n      }\n\n      if (data.references) {\n        data.normalizedHeaders.references = this.message._encodeHeaderValue('references', data.references);\n      }\n\n      if (data.inReplyTo) {\n        data.normalizedHeaders['in-reply-to'] = this.message._encodeHeaderValue('in-reply-to', data.inReplyTo);\n      }\n\n      return callback(null, data);\n    });\n  }\n\n  setMailerHeader() {\n    if (!this.message || !this.data.xMailer) {\n      return;\n    }\n\n    this.message.setHeader('X-Mailer', this.data.xMailer);\n  }\n\n  setPriorityHeaders() {\n    if (!this.message || !this.data.priority) {\n      return;\n    }\n\n    switch ((this.data.priority || '').toString().toLowerCase()) {\n      case 'high':\n        this.message.setHeader('X-Priority', '1 (Highest)');\n        this.message.setHeader('X-MSMail-Priority', 'High');\n        this.message.setHeader('Importance', 'High');\n        break;\n\n      case 'low':\n        this.message.setHeader('X-Priority', '5 (Lowest)');\n        this.message.setHeader('X-MSMail-Priority', 'Low');\n        this.message.setHeader('Importance', 'Low');\n        break;\n\n      default: // do not add anything, since all messages are 'Normal' by default\n\n    }\n  }\n\n  setListHeaders() {\n    if (!this.message || !this.data.list || typeof this.data.list !== 'object') {\n      return;\n    } // add optional List-* headers\n\n\n    if (this.data.list && typeof this.data.list === 'object') {\n      this._getListHeaders(this.data.list).forEach(listHeader => {\n        listHeader.value.forEach(value => {\n          this.message.addHeader(listHeader.key, value);\n        });\n      });\n    }\n  }\n\n  _getListHeaders(listData) {\n    // make sure an url looks like <protocol:url>\n    return Object.keys(listData).map(key => ({\n      key: 'list-' + key.toLowerCase().trim(),\n      value: [].concat(listData[key] || []).map(value => ({\n        prepared: true,\n        foldLines: true,\n        value: [].concat(value || []).map(value => {\n          if (typeof value === 'string') {\n            value = {\n              url: value\n            };\n          }\n\n          if (value && value.url) {\n            if (key.toLowerCase().trim() === 'id') {\n              // List-ID: \"comment\" <domain>\n              let comment = value.comment || '';\n\n              if (mimeFuncs.isPlainText(comment)) {\n                comment = '\"' + comment + '\"';\n              } else {\n                comment = mimeFuncs.encodeWord(comment);\n              }\n\n              return (value.comment ? comment + ' ' : '') + this._formatListUrl(value.url).replace(/^<[^:]+\\/{,2}/, '');\n            } // List-*: <http://domain> (comment)\n\n\n            let comment = value.comment || '';\n\n            if (!mimeFuncs.isPlainText(comment)) {\n              comment = mimeFuncs.encodeWord(comment);\n            }\n\n            return this._formatListUrl(value.url) + (value.comment ? ' (' + comment + ')' : '');\n          }\n\n          return '';\n        }).filter(value => value).join(', ')\n      }))\n    }));\n  }\n\n  _formatListUrl(url) {\n    url = url.replace(/[\\s<]+|[\\s>]+/g, '');\n\n    if (/^(https?|mailto|ftp):/.test(url)) {\n      return '<' + url + '>';\n    }\n\n    if (/^[^@]+@[^@]+$/.test(url)) {\n      return '<mailto:' + url + '>';\n    }\n\n    return '<http://' + url + '>';\n  }\n\n}\n\nmodule.exports = MailMessage;","map":null,"metadata":{},"sourceType":"script"}