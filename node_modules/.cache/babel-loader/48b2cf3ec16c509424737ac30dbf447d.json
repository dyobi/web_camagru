{"ast":null,"code":"'use strict';\n\nconst packageData = require('../../package.json');\n\nconst shared = require('../shared');\n\nconst LeWindows = require('../sendmail-transport/le-windows');\n\nconst LeUnix = require('../sendmail-transport/le-unix');\n/**\n * Generates a Transport object for streaming\n *\n * Possible options can be the following:\n *\n *  * **buffer** if true, then returns the message as a Buffer object instead of a stream\n *  * **newline** either 'windows' or 'unix'\n *\n * @constructor\n * @param {Object} optional config parameter\n */\n\n\nclass StreamTransport {\n  constructor(options) {\n    options = options || {};\n    this.options = options || {};\n    this.name = 'StreamTransport';\n    this.version = packageData.version;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'stream-transport'\n    });\n    this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n  }\n  /**\n   * Compiles a mailcomposer message and forwards it to handler that sends it\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n\n\n  send(mail, done) {\n    // We probably need this in the output\n    mail.message.keepBcc = true;\n    let envelope = mail.data.envelope || mail.message.getEnvelope();\n    let messageId = mail.message.messageId();\n    let recipients = [].concat(envelope.to || []);\n\n    if (recipients.length > 3) {\n      recipients.push('...and ' + recipients.splice(2).length + ' more');\n    }\n\n    this.logger.info({\n      tnx: 'send',\n      messageId\n    }, 'Sending message %s to <%s> using %s line breaks', messageId, recipients.join(', '), this.winbreak ? '<CR><LF>' : '<LF>');\n    setImmediate(() => {\n      let sourceStream;\n      let stream;\n      let transform;\n\n      try {\n        transform = this.winbreak ? new LeWindows() : new LeUnix();\n        sourceStream = mail.message.createReadStream();\n        stream = sourceStream.pipe(transform);\n        sourceStream.on('error', err => stream.emit('error', err));\n      } catch (E) {\n        this.logger.error({\n          err: E,\n          tnx: 'send',\n          messageId\n        }, 'Creating send stream failed for %s. %s', messageId, E.message);\n        return done(E);\n      }\n\n      if (!this.options.buffer) {\n        stream.once('error', err => {\n          this.logger.error({\n            err,\n            tnx: 'send',\n            messageId\n          }, 'Failed creating message for %s. %s', messageId, err.message);\n        });\n        return done(null, {\n          envelope: mail.data.envelope || mail.message.getEnvelope(),\n          messageId,\n          message: stream\n        });\n      }\n\n      let chunks = [];\n      let chunklen = 0;\n      stream.on('readable', () => {\n        let chunk;\n\n        while ((chunk = stream.read()) !== null) {\n          chunks.push(chunk);\n          chunklen += chunk.length;\n        }\n      });\n      stream.once('error', err => {\n        this.logger.error({\n          err,\n          tnx: 'send',\n          messageId\n        }, 'Failed creating message for %s. %s', messageId, err.message);\n        return done(err);\n      });\n      stream.on('end', () => done(null, {\n        envelope: mail.data.envelope || mail.message.getEnvelope(),\n        messageId,\n        message: Buffer.concat(chunks, chunklen)\n      }));\n    });\n  }\n\n}\n\nmodule.exports = StreamTransport;","map":null,"metadata":{},"sourceType":"script"}