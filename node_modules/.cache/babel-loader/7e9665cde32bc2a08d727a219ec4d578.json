{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\n\n\nclass MessageParser extends Transform {\n  constructor(options) {\n    super(options);\n    this.lastBytes = Buffer.alloc(4);\n    this.headersParsed = false;\n    this.headerBytes = 0;\n    this.headerChunks = [];\n    this.rawHeaders = false;\n    this.bodySize = 0;\n  }\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n\n\n  updateLastBytes(data) {\n    let lblen = this.lastBytes.length;\n    let nblen = Math.min(data.length, lblen); // shift existing bytes\n\n    for (let i = 0, len = lblen - nblen; i < len; i++) {\n      this.lastBytes[i] = this.lastBytes[i + nblen];\n    } // add new bytes\n\n\n    for (let i = 1; i <= nblen; i++) {\n      this.lastBytes[lblen - i] = data[data.length - i];\n    }\n  }\n  /**\n   * Finds and removes message headers from the remaining body. We want to keep\n   * headers separated until final delivery to be able to modify these\n   *\n   * @param {Buffer} data Next chunk of data\n   * @return {Boolean} Returns true if headers are already found or false otherwise\n   */\n\n\n  checkHeaders(data) {\n    if (this.headersParsed) {\n      return true;\n    }\n\n    let lblen = this.lastBytes.length;\n    let headerPos = 0;\n    this.curLinePos = 0;\n\n    for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n      let chr;\n\n      if (i < lblen) {\n        chr = this.lastBytes[i];\n      } else {\n        chr = data[i - lblen];\n      }\n\n      if (chr === 0x0a && i) {\n        let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n        let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n\n        if (pr1 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        } else if (pr1 === 0x0d && pr2 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        }\n      }\n    }\n\n    if (this.headersParsed) {\n      this.headerChunks.push(data.slice(0, headerPos));\n      this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.headerChunks = null;\n      this.emit('headers', this.parseHeaders());\n\n      if (data.length - 1 > headerPos) {\n        let chunk = data.slice(headerPos);\n        this.bodySize += chunk.length; // this would be the first chunk of data sent downstream\n\n        setImmediate(() => this.push(chunk));\n      }\n\n      return false;\n    } else {\n      this.headerBytes += data.length;\n      this.headerChunks.push(data);\n    } // store last 4 bytes to catch header break\n\n\n    this.updateLastBytes(data);\n    return false;\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    let headersFound;\n\n    try {\n      headersFound = this.checkHeaders(chunk);\n    } catch (E) {\n      return callback(E);\n    }\n\n    if (headersFound) {\n      this.bodySize += chunk.length;\n      this.push(chunk);\n    }\n\n    setImmediate(callback);\n  }\n\n  _flush(callback) {\n    if (this.headerChunks) {\n      let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.bodySize += chunk.length;\n      this.push(chunk);\n      this.headerChunks = null;\n    }\n\n    callback();\n  }\n\n  parseHeaders() {\n    let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n\n    for (let i = lines.length - 1; i > 0; i--) {\n      if (/^\\s/.test(lines[i])) {\n        lines[i - 1] += '\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    return lines.filter(line => line.trim()).map(line => ({\n      key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n      line\n    }));\n  }\n\n}\n\nmodule.exports = MessageParser;","map":null,"metadata":{},"sourceType":"script"}