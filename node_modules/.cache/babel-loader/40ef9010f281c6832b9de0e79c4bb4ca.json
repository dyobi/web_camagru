{"ast":null,"code":"'use strict'; // module to handle cookies\n\nconst urllib = require('url');\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\n\nclass Cookies {\n  constructor(options) {\n    this.options = options || {};\n    this.cookies = [];\n  }\n  /**\n   * Stores a cookie string to the cookie storage\n   *\n   * @param {String} cookieStr Value from the 'Set-Cookie:' header\n   * @param {String} url Current URL\n   */\n\n\n  set(cookieStr, url) {\n    let urlparts = urllib.parse(url || '');\n    let cookie = this.parse(cookieStr);\n    let domain;\n\n    if (cookie.domain) {\n      domain = cookie.domain.replace(/^\\./, ''); // do not allow cross origin cookies\n\n      if ( // can't be valid if the requested domain is shorter than current hostname\n      urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used\n      ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain) {\n        cookie.domain = urlparts.hostname;\n      }\n    } else {\n      cookie.domain = urlparts.hostname;\n    }\n\n    if (!cookie.path) {\n      cookie.path = this.getPath(urlparts.pathname);\n    } // if no expire date, then use sessionTimeout value\n\n\n    if (!cookie.expires) {\n      cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n    }\n\n    return this.add(cookie);\n  }\n  /**\n   * Returns cookie string for the 'Cookie:' header.\n   *\n   * @param {String} url URL to check for\n   * @returns {String} Cookie header or empty string if no matches were found\n   */\n\n\n  get(url) {\n    return this.list(url).map(cookie => cookie.name + '=' + cookie.value).join('; ');\n  }\n  /**\n   * Lists all valied cookie objects for the specified URL\n   *\n   * @param {String} url URL to check for\n   * @returns {Array} An array of cookie objects\n   */\n\n\n  list(url) {\n    let result = [];\n    let i;\n    let cookie;\n\n    for (i = this.cookies.length - 1; i >= 0; i--) {\n      cookie = this.cookies[i];\n\n      if (this.isExpired(cookie)) {\n        this.cookies.splice(i, i);\n        continue;\n      }\n\n      if (this.match(cookie, url)) {\n        result.unshift(cookie);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Parses cookie string from the 'Set-Cookie:' header\n   *\n   * @param {String} cookieStr String from the 'Set-Cookie:' header\n   * @returns {Object} Cookie object\n   */\n\n\n  parse(cookieStr) {\n    let cookie = {};\n    (cookieStr || '').toString().split(';').forEach(cookiePart => {\n      let valueParts = cookiePart.split('=');\n      let key = valueParts.shift().trim().toLowerCase();\n      let value = valueParts.join('=').trim();\n      let domain;\n\n      if (!key) {\n        // skip empty parts\n        return;\n      }\n\n      switch (key) {\n        case 'expires':\n          value = new Date(value); // ignore date if can not parse it\n\n          if (value.toString() !== 'Invalid Date') {\n            cookie.expires = value;\n          }\n\n          break;\n\n        case 'path':\n          cookie.path = value;\n          break;\n\n        case 'domain':\n          domain = value.toLowerCase();\n\n          if (domain.length && domain.charAt(0) !== '.') {\n            domain = '.' + domain; // ensure preceeding dot for user set domains\n          }\n\n          cookie.domain = domain;\n          break;\n\n        case 'max-age':\n          cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n          break;\n\n        case 'secure':\n          cookie.secure = true;\n          break;\n\n        case 'httponly':\n          cookie.httponly = true;\n          break;\n\n        default:\n          if (!cookie.name) {\n            cookie.name = key;\n            cookie.value = value;\n          }\n\n      }\n    });\n    return cookie;\n  }\n  /**\n   * Checks if a cookie object is valid for a specified URL\n   *\n   * @param {Object} cookie Cookie object\n   * @param {String} url URL to check for\n   * @returns {Boolean} true if cookie is valid for specifiec URL\n   */\n\n\n  match(cookie, url) {\n    let urlparts = urllib.parse(url || ''); // check if hostname matches\n    // .foo.com also matches subdomains, foo.com does not\n\n    if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {\n      return false;\n    } // check if path matches\n\n\n    let path = this.getPath(urlparts.pathname);\n\n    if (path.substr(0, cookie.path.length) !== cookie.path) {\n      return false;\n    } // check secure argument\n\n\n    if (cookie.secure && urlparts.protocol !== 'https:') {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Adds (or updates/removes if needed) a cookie object to the cookie storage\n   *\n   * @param {Object} cookie Cookie value to be stored\n   */\n\n\n  add(cookie) {\n    let i;\n    let len; // nothing to do here\n\n    if (!cookie || !cookie.name) {\n      return false;\n    } // overwrite if has same params\n\n\n    for (i = 0, len = this.cookies.length; i < len; i++) {\n      if (this.compare(this.cookies[i], cookie)) {\n        // check if the cookie needs to be removed instead\n        if (this.isExpired(cookie)) {\n          this.cookies.splice(i, 1); // remove expired/unset cookie\n\n          return false;\n        }\n\n        this.cookies[i] = cookie;\n        return true;\n      }\n    } // add as new if not already expired\n\n\n    if (!this.isExpired(cookie)) {\n      this.cookies.push(cookie);\n    }\n\n    return true;\n  }\n  /**\n   * Checks if two cookie objects are the same\n   *\n   * @param {Object} a Cookie to check against\n   * @param {Object} b Cookie to check against\n   * @returns {Boolean} True, if the cookies are the same\n   */\n\n\n  compare(a, b) {\n    return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n  }\n  /**\n   * Checks if a cookie is expired\n   *\n   * @param {Object} cookie Cookie object to check against\n   * @returns {Boolean} True, if the cookie is expired\n   */\n\n\n  isExpired(cookie) {\n    return cookie.expires && cookie.expires < new Date() || !cookie.value;\n  }\n  /**\n   * Returns normalized cookie path for an URL path argument\n   *\n   * @param {String} pathname\n   * @returns {String} Normalized path\n   */\n\n\n  getPath(pathname) {\n    let path = (pathname || '/').split('/');\n    path.pop(); // remove filename part\n\n    path = path.join('/').trim(); // ensure path prefix /\n\n    if (path.charAt(0) !== '/') {\n      path = '/' + path;\n    } // ensure path suffix /\n\n\n    if (path.substr(-1) !== '/') {\n      path += '/';\n    }\n\n    return path;\n  }\n\n}\n\nmodule.exports = Cookies;","map":null,"metadata":{},"sourceType":"script"}