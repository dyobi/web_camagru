{"ast":null,"code":"'use strict'; // streams through a message body and calculates relaxed body hash\n\nconst Transform = require('stream').Transform;\n\nconst crypto = require('crypto');\n\nclass RelaxedBody extends Transform {\n  constructor(options) {\n    super();\n    options = options || {};\n    this.chunkBuffer = [];\n    this.chunkBufferLen = 0;\n    this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');\n    this.remainder = '';\n    this.byteLength = 0;\n    this.debug = options.debug;\n    this._debugBody = options.debug ? [] : false;\n  }\n\n  updateHash(chunk) {\n    let bodyStr; // find next remainder\n\n    let nextRemainder = ''; // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line\n    // If we get another chunk that does not match this description then we can restore the previously processed data\n\n    let state = 'file';\n\n    for (let i = chunk.length - 1; i >= 0; i--) {\n      let c = chunk[i];\n\n      if (state === 'file' && (c === 0x0a || c === 0x0d)) {// do nothing, found \\n or \\r at the end of chunk, stil end of file\n      } else if (state === 'file' && (c === 0x09 || c === 0x20)) {\n        // switch to line ending mode, this is the last non-empty line\n        state = 'line';\n      } else if (state === 'line' && (c === 0x09 || c === 0x20)) {// do nothing, found ' ' or \\t at the end of line, keep processing the last non-empty line\n      } else if (state === 'file' || state === 'line') {\n        // non line/file ending character found, switch to body mode\n        state = 'body';\n\n        if (i === chunk.length - 1) {\n          // final char is not part of line end or file end, so do nothing\n          break;\n        }\n      }\n\n      if (i === 0) {\n        // reached to the beginning of the chunk, check if it is still about the ending\n        // and if the remainder also matches\n        if (state === 'file' && (!this.remainder || /[\\r\\n]$/.test(this.remainder)) || state === 'line' && (!this.remainder || /[ \\t]$/.test(this.remainder))) {\n          // keep everything\n          this.remainder += chunk.toString('binary');\n          return;\n        } else if (state === 'line' || state === 'file') {\n          // process existing remainder as normal line but store the current chunk\n          nextRemainder = chunk.toString('binary');\n          chunk = false;\n          break;\n        }\n      }\n\n      if (state !== 'body') {\n        continue;\n      } // reached first non ending byte\n\n\n      nextRemainder = chunk.slice(i + 1).toString('binary');\n      chunk = chunk.slice(0, i + 1);\n      break;\n    }\n\n    let needsFixing = !!this.remainder;\n\n    if (chunk && !needsFixing) {\n      // check if we even need to change anything\n      for (let i = 0, len = chunk.length; i < len; i++) {\n        if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {\n          // missing \\r before \\n\n          needsFixing = true;\n          break;\n        } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {\n          // trailing WSP found\n          needsFixing = true;\n          break;\n        } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {\n          // multiple spaces found, needs to be replaced with just one\n          needsFixing = true;\n          break;\n        } else if (chunk[i] === 0x09) {\n          // TAB found, needs to be replaced with a space\n          needsFixing = true;\n          break;\n        }\n      }\n    }\n\n    if (needsFixing) {\n      bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');\n      this.remainder = nextRemainder;\n      bodyStr = bodyStr.replace(/\\r?\\n/g, '\\n') // use js line endings\n      .replace(/[ \\t]*$/gm, '') // remove line endings, rtrim\n      .replace(/[ \\t]+/gm, ' ') // single spaces\n      .replace(/\\n/g, '\\r\\n'); // restore rfc822 line endings\n\n      chunk = Buffer.from(bodyStr, 'binary');\n    } else if (nextRemainder) {\n      this.remainder = nextRemainder;\n    }\n\n    if (this.debug) {\n      this._debugBody.push(chunk);\n    }\n\n    this.bodyHash.update(chunk);\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.updateHash(chunk);\n    this.byteLength += chunk.length;\n    this.push(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    // generate final hash and emit it\n    if (/[\\r\\n]$/.test(this.remainder) && this.byteLength > 2) {\n      // add terminating line end\n      this.bodyHash.update(Buffer.from('\\r\\n'));\n    }\n\n    if (!this.byteLength) {\n      // emit empty line buffer to keep the stream flowing\n      this.push(Buffer.from('\\r\\n')); // this.bodyHash.update(Buffer.from('\\r\\n'));\n    }\n\n    this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);\n    callback();\n  }\n\n}\n\nmodule.exports = RelaxedBody;","map":null,"metadata":{},"sourceType":"script"}